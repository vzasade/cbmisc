key generation algorithm
------------------------
that selects a private key uniformly at random from a set of possible private keys. The algorithm outputs the private key and a corresponding public key.

signing algorithm
-----------------
that, given a message and a private key, produces a signature.

signature verifying algorithm
-----------------------------
that, given the message, public key and signature, either accepts or rejects the message's claim to authenticity.

certificate
-----------
The certificate is, nominally, a container for the public key. It includes the public key, the server name, some extra information about the server, and a signature computed by a certification authority.

chain
-----
When the server sends its public key to a client, it actually sends its certificate, with a few other certificates (the certificate which contains the public key of the CA which signed its certificate, and the certificate for the CA which signed the CA's certificate, and so on). Certificates are intrinsically public objects.

pfx
---
A ".pfx" file is a PKCS#12 archive: a bag which can contain a lot of objects with optional password protection; but, usually, a PKCS#12 archive contains a certificate (possibly with its assorted set of CA certificates) and the corresponding private key.

------------------------------------------------------

How does SSL/TLS work?
http://security.stackexchange.com/questions/20803/how-does-ssl-tls-work

How is it possible that people observing an HTTPS connection being established wouldn't know how to decrypt it?
http://security.stackexchange.com/questions/6290/how-is-it-possible-that-people-observing-an-https-connection-being-established-w

What’s in a certificate chain and why?
https://unmitigatedrisk.com/?p=397

How do SSL chains work?
http://superuser.com/questions/347588/how-do-ssl-chains-work

X.509
https://en.wikipedia.org/wiki/X.509

SSL Made Easy for Beginners
https://info.ssl.com/ssl-made-easy-for-beginners/

Configure mongod and mongos for TLS/SSL
http://docs.mongodb.org/master/tutorial/configure-ssl/

Examples of openssl commands:
https://www.sslshopper.com/article-most-common-openssl-commands.html

-------------------------------------------------------------------------

view certificate

openssl x509 -in myroot-ca.crt -text -noout

generate root key and cert

openssl genrsa -out myroot-ca.key 4096
openssl req -new -x509 -days 1826 -key myroot-ca.key -out myroot-ca.crt

generate intermediate cert

openssl genrsa -out interm.key 4096
openssl req -new -key interm.key -out interm.csr
openssl x509 -req -days 730 -in interm.csr -CA myroot-ca.crt -CAkey myroot-ca.key -set_serial 01 -out interm.crt
cat interm.crt myroot-ca.crt > chain.pem

chain for node
--------------
cat server_correct.crt interm.crt > node_chain.pem
cat server_correct.crt interm.crt myroot-ca.crt > node_chain_with_root.pem

generate node cert

openssl genrsa -out server.key 4096     
openssl req -new -key server.key -out server.csr
openssl x509 -req -days 365 -in server.csr -CA interm.crt -CAkey interm.key -CAcreateserial -out server.crt
openssl pkcs12 -export -out server.pfx -inkey server.key -in server.crt -certfile chain.pem

Note: 

verify:

openssl verify -verbose -CAfile chain.pem  server.crt
NO: openssl verify -verbose -CAfile myroot-ca.crt  server.crt
NO: openssl verify -verbose -CAfile interm.crt  server.crt


----------------------------------------------

current files:

all in data/n_0/config/

local-ssl-cert.pem
local-ssl-pkey.pem
local-ssl-meta - needed to make sure that local cert was generated from cluster cert


/// passed to query, ssl proxy, capi service, rest service
ssl-cert-key.pem - local cert + local key
ssl-cert-key.pem-ca - cluster cert

memcached-key.pem - local key
memcached-cert.pem - local cert + cluster cert

configured in memcached.json
"ssl":{"key":"/Users/artem/Work/watson/ns_server/data/n_0/config/memcached-key.pem","cert":"/Users/artem/Work/watson/ns_server/data/n_0/config/memcached-cert.pem"}}

cluster cert management:
ns_server_cert.erl

local certificates management:
ns_ssl_services_setup.erl


-----------------------------

https://127.0.0.1:19000/index.html


PEM Format
It is the most common format that Certificate Authorities issue certificates in. It contains the ‘—–BEGIN CERTIFICATE—–” and “—–END CERTIFICATE—–” statements.

Several PEM certificates and even the Private key can be included in one file, one below the other. But most platforms(eg:- Apache) expects the certificates and Private key to be in separate files.
> They are Base64 encoded ACII files
> They have extensions such as .pem, .crt, .cer, .key
> Apache and similar servers uses PEM format certificates

PFX/PKCS#12
They are used for storing the Server certificate, any Intermediate certificates & Private key in one encryptable file.
> They are Binary format files
> They have extensions .pfx, .p12
> Typically used on Windows OS to import and export certificates and Private keys

Convert PEM to PFX
——————————————————————————————————————————————————
$ openssl pkcs12 -export -out certificate.pfx -inkey privateKey.key -in certificate.crt -certfile CAcert.crt
———————————————————————————————————————————

Convert PFX to PEM
——————————————————————————————–
$ openssl pkcs12 -in certificate.pfx -out certificate.cer -nodes
——————————————————————————————–

NOTE: While converting PFX to PEM format, openssl will put all the Certificates and Private Key into a single file. You will need to open the file in Text editor and copy each Certificate & Private key(including the BEGIN/END statements) to its own individual text file and save them as certificate.cer, CAcert.cer, privateKey.key respectively.


Chain:
-----
cat clustercert.pem intermediate_ca_cert.pem root_ca.pem >> cbasechain.pem 
openssl pkcs12 -export -in cbasechain.pem -out cbasechain.pfx

The certificates in the chain file MUST be ordered, with each certificate immediately following the certificate it signed, and the final well-known root CA certificate must thus be last.

Order in chain:
http://blog.edgecloud.com/post/19519955133/ssl-certificate-chain-order-matters

<your certificate>
<your cert signer>
<signer for your cert signer>
<etc>

The last one can be the root certificate, but technically, it doesn’t need to be in there, and I found some references around the web that certain poorly built SSL clients will fail out if the root certificate is in the file.


Log
---

ip: 192.168.0.76

public_key.erl
ssl_certificate.erl

Correct certificate server_correct.crt:
subject=/C=US/ST=CA/L=San Francisco/O=Internet Widgits Pty Ltd/CN=192.168.0.76

hostname validation library:
https://github.com/benoitc/ssl_verify_hostname/blob/master/src/ssl_verify_hostname.erl

ns_config
---------

{cluster_ca, [{pem, <pem encoded ca>},
              {subject, <sub>},
              {expires, <timestamp>}]}
{{node, node(), cert}, [{validated, yes/no},
                        {expires, <timestamp>}]}


existing api
------------

GET /pools/default/certificate
POST /controller/regenerateCertificate

proposed api
------------

POST /controller/uploadClusterCA
POST /controller/setNodeCertificate

curl -X POST --data-binary "@/Users/artem/Work/cert/myroot-ca.crt" http://Administrator:asdasd@127.0.0.1:9000/controller/uploadClusterCA

curl -X POST --data "chain=/Users/artem/Work/cert/node_chain.pem&pkey=/Users/artem/Work/cert/server.key" http://Administrator:asdasd@127.0.0.1:9000/controller/setNodeCertificate

curl -X POST --data "chain=/Users/artem/Work/cert/localhost_chain.pem&pkey=/Users/artem/Work/cert/server.key" http://Administrator:asdasd@127.0.0.1:9000/controller/setNodeCertificate


keytool -importcert -file gen.crt -keystore javakeystore
keytool -importcert -file myroot-ca.crt -alias superca -keystore javakeystore
keytool -list -keystore javakeystore


------------------------------------------------

Uploaded:
MEMCACHED CHAIN:
Subject: "C=US, ST=CA, L=San Francisco, O=Internet Widgits Pty Ltd, CN=192.168.0.76"
Issuer: "C=US, ST=CA, L=San Francisco, O=Not That Important Authority"
Validity: {{{2015,11,13},{22,27,28}},{{2016,11,12},{22,27,28}}}
********
Subject: "C=US, ST=CA, L=San Francisco, O=Not That Important Authority"
Issuer: "C=US, ST=CA, L=San Francisco, O=Super Root Authority"
Validity: {{{2015,10,5},{0,36,31}},{{2017,10,4},{0,36,31}}}
********
Subject: "C=US, ST=CA, L=San Francisco, O=Super Root Authority"
Issuer: "C=US, ST=CA, L=San Francisco, O=Super Root Authority"
Validity: {{{2015,10,5},{0,31,56}},{{2020,10,4},{0,31,56}}}
*

CI

IC

Generated:
MEMCACHED CHAIN:
Subject: "CN=127.0.0.1"
Issuer: "CN=Couchbase Server 0df4efb8"
Validity: {{{2013,1,1},{0,0,0}},{{2049,12,31},{23,59,59}}}
********
Subject: "CN=Couchbase Server 0df4efb8"
Issuer: "CN=Couchbase Server 0df4efb8"
Validity: {{{2013,1,1},{0,0,0}},{{2049,12,31},{23,59,59}}}


Exception for uploaded chain

Caused by: sun.security.validator.ValidatorException: No trusted certificate found


New way to generate certs:
--------------------------
go run gencert.go -store-to=/Users/artem/Work/cert/newcerts/root -common-name=Root\ Authority
go run gencert.go -store-to=/Users/artem/Work/cert/newcerts/interm -sign-with=/Users/artem/Work/cert/newcerts/root -common-name=Intemediate\ Authority
go run gencert.go -store-to=/Users/artem/Work/cert/newcerts/local -sign-with=/Users/artem/Work/cert/newcerts/interm -common-name=127.0.0.1 -final=true

cat local.crt interm.crt > long_chain.pem

curl -X POST --data "chain=/Users/artem/Work/cert/newcerts/long_chain.pem&pkey=/Users/artem/Work/cert/newcerts/local.key" http://Administrator:asdasd@127.0.0.1:9000/controller/setNodeCertificate

short chain
-----------
go run gencert.go -store-to=/Users/artem/Work/cert/newcerts/simple -sign-with=/Users/artem/Work/cert/newcerts/root -common-name=127.0.0.1 -final=true
curl -X POST --data "chain=/Users/artem/Work/cert/newcerts/simple.crt&pkey=/Users/artem/Work/cert/newcerts/simple.key" http://Administrator:asdasd@127.0.0.1:9000/controller/setNodeCertificate


curl -X POST --data-binary "@/Users/artem/Work/cert/newcerts/root.crt" http://Administrator:asdasd@127.0.0.1:9000/controller/uploadClusterCA

---------------------------------------------------------------------
GENERATED
---------------------------------------------------------------------
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number:
            14:1d:bd:f5:35:f1:2b:7a
        Signature Algorithm: sha256WithRSAEncryption
        Issuer: CN=Couchbase Server 0df4efb8
        Validity
            Not Before: Jan  1 00:00:00 2013 GMT
            Not After : Dec 31 23:59:59 2049 GMT
        Subject: CN=127.0.0.1
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
            RSA Public Key: (1024 bit)
        X509v3 extensions:
            X509v3 Key Usage: critical
                Digital Signature, Key Encipherment
            X509v3 Extended Key Usage: 
                TLS Web Server Authentication
            X509v3 Basic Constraints: critical
                CA:FALSE
            X509v3 Subject Alternative Name: 
                IP Address:127.0.0.1
    Signature Algorithm: sha256WithRSAEncryption


Certificate:
    Data:
        Version: 1 (0x0)
        Serial Number:
            cc:9c:6a:79:97:95:aa:0f
        Signature Algorithm: sha1WithRSAEncryption
        Issuer: C=US, ST=CA, L=San Francisco, O=Not That Important Authority
        Validity
            Not Before: Dec  7 21:37:10 2015 GMT
            Not After : Dec  6 21:37:10 2016 GMT
        Subject: C=AU, ST=Some-State, O=Internet Widgits Pty Ltd, CN=127.0.0.1
        Subject Public Key Info:
            Public Key Algorithm: rsaEncryption
            RSA Public Key: (4096 bit)
    Signature Algorithm: sha1WithRSAEncryption

-----------------------------------

node: engageCluster2 - engage_cluster

cluster : do_add_node_engaged

------------------------------------------

REFRESH:
ns_ssl_services_setup.erl

set_node_certificate_chain
delete {node, node(), cert}
write files
ns_config:set({node, node(), cert}, Props),




case ns_config:search(Config, {node, Node, cert}) of
{value, Props}




ls ~/Work/watson/ns_server/data/n_0/



latest
------

curl -X GET http://Administrator:asdasd@127.0.0.1:9000/pools/default/certificate


curl -X POST --data-binary "@/Users/artem/Work/cert/newcerts/root.crt" http://Administrator:asdasd@127.0.0.1:9000/controller/uploadClusterCA

mkdir ~/Work/watson/ns_server/data/n_0/inbox

cp /Users/artem/Work/cert/newcerts/long_chain.pem ~/Work/watson/ns_server/data/n_0/inbox/chain.pem

cp /Users/artem/Work/cert/newcerts/local.key ~/Work/watson/ns_server/data/n_0/inbox/pkey.pem

curl -X POST http://Administrator:asdasd@127.0.0.1:9000/node/controller/reloadCertificate



TypeError: Cannot read property 'isAuthenticated' of undefined
    at http://127.0.0.1:9000/ui/app/app.js:48:18
    at processQueue (http://127.0.0.1:9000/ui/libs/angular.js:14634:28)
    at http://127.0.0.1:9000/ui/libs/angular.js:14650:27
    at Scope.$eval (http://127.0.0.1:9000/ui/libs/angular.js:15916:28)
    at Scope.$digest (http://127.0.0.1:9000/ui/libs/angular.js:15727:31)
    at Scope.$apply (http://127.0.0.1:9000/ui/libs/angular.js:16024:24)
    at done (http://127.0.0.1:9000/ui/libs/angular.js:10511:47)
    at completeRequest (http://127.0.0.1:9000/ui/libs/angular.js:10683:7)
    at XMLHttpRequest.requestLoaded (http://127.0.0.1:9000/ui/libs/angular.js:10624:9)


--------------------------------------------------------------------------------

REST API's for managing certificates:

GET /pools/default/certificate

Returns current Cluster CA. Without parameters works the same way as it worked pre Watson.
With parameter extended=true returns extended certificate info:
{"cert": {"type" : ..., "pem" : ..., "subject" : ..., "expires" : ...}, warnings: []}
type - generated or uploaded
pem - pem encoded certificate
subject - abbreviated certificate subject
expires - expiration data
warnings - warnings to be displayed in UI

example:
$ curl -X GET http://user:password@127.0.0.1:9000/pools/default/certificate?extended=true

{"cert":{"type":"uploaded","pem":"-----BEGIN CERTIFICATE-----\nMIIC6DCCAdKgAwIBAgIIFB4YAjF90MgwCwYJKoZIhvcNAQELMBkxFzAVBgNVBAMT\nDlJvb3QgQXV0aG9yaXR5MB4XDTEzMDEwMTAwMDAwMFoXDTQ5MTIzMTIzNTk1OVow\nGTEXMBUGA1UEAxMOUm9vdCBBdXRob3JpdHkwggEiMA0GCSqGSIb3DQEBAQUAA4IB\nDwAwggEKAoIBAQDBum06stdiYQI2HQyjZeg3s0Pz8CziXqSg4GicaeKNloOfASwl\n+8LQDX5Dgb+Mc4ZxXYo9/7eVlsvSiZPZcv9D2pubjR4ZtEDY5t9AlXDiYTHK0zxG\nB34Llnz3gJmkAEAsjy4g+RfwpJS4kGVzFhrzgxOQJIJogZnLduk+mHFjyXI3X+8y\nf4KF8ijrXP8bbfa0kM1tjvcttaK7vTEP+G/mbOEFZErhScXT9eKRlgwsitaH7kI0\nimpqg3YX1znLQ5n+eLzeVR1HhszJrFaaaRHL0esml6jLEcZBBitJSuEuaMLp9ZWB\nA479ZHmN/vZc1SwfMrCE2+TE0ytW3O7eFXjXAgMBAAGjODA2MA4GA1UdDwEB/wQE\nAwIApDATBgNVHSUEDDAKBggrBgEFBQcDATAPBgNVHRMBAf8EBTADAQH/MAsGCSqG\nSIb3DQEBCwOCAQEACReNkvIXhjPO0rWpgdVSqnLrjUb6DJf0n4Uyq6PfukeEfBtF\n59L+xUcoY6NFM5N6qRlGgg0eqTCVmQ6N6lKnnZRH23g3BPLjU2EqAtBHIc5f2JoM\nd1E4UD2v20MlFoeHL0YljGTywlqStoZYc2uYUJnJAVq2D1dWcwP2S7G6caLHMlAl\nQVYIZvjCGuqGckV1EqOTT7uKPH9ulljtYKVIq/aTbINjX0hJsaoN2hOfHVTp2Shq\neLMwgfNdg6zWRyeL/Mi/3jmSjSH61zyHva2xlY8Pl6Zurx/+pF1qN27+P8tCjsDO\nD2hAADXr8WRqC1Sd+xAGcFkvqOOFv/HRxDej3A==\n-----END CERTIFICATE-----\n","subject":"CN=Root Authority","expires":"2049-12-31T15:59:59.000Z"},"warnings":[{"node":"n_0@127.0.0.1","message":"Certificate is not signed with cluster CA."}]}

Possible warmnings:
{"node":"n_0@127.0.0.1","message":"Certificate is not signed with cluster CA."}
{"node":"n_0@127.0.0.1","message":"Certificate is expired."}
{"node":"n_0@127.0.0.1","message":"Certificate will expire soon.","expires":"2049-12-31T15:59:59.000Z"}

POST /controller/uploadClusterCA

Uploads root certificate (Cluster CA) to the cluster. That certificate will be displayed in UI and used for XDCR replications and for clients certificate stores.

example:
curl -X POST --data-binary "@/path/root.crt" http://user:password@127.0.0.1:9000/controller/uploadClusterCA

returns:
Same output as GET /pools/default/certificate?extended=true

POST /node/controller/reloadCertificate

Grabs chain.pem and pkey.pem from the <data folder>/inbox/ directory and applies them to the node.

example:
curl -X POST http://user:password@127.0.0.1:9000/node/controller/reloadCertificate

Returns:
200 - if success
400 with errpor message if failed. 

